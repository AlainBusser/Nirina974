// Generated by CoffeeScript 2.2.3
(function() {
    // set up SVG for D3
  var DnDFileController, circle, circlesGroup, colors, couleur, dnd, drag_line, force, height, i, j, keydown, keyup, lastKeyDown, lastNodeId, links, mousedown, mousedown_link, mousedown_node, mousemove, mouseup, mouseup_node, nodes, path, pathsGroup, resetMouseVars, restart, save, selected_link, selected_node, spliceLinksForNode, svg, tick, width;

  width = 800;

  height = 480;

  colors = d3.scale.category10();

  // define arrow markers for graph links
  svg = d3.select('#graf').append('svg').attr('oncontextmenu', 'return false;').attr('width', width).attr('height', height);

  // line displayed when dragging new nodes
  drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');

  // set up initial nodes and links
  //  - nodes are known by 'id', not by index in array.
  //  - reflexive edges are indicated on the node (as a bold black circle).
  //  - links are always source < target; edge directions are set by 'left' and 'right'.
  nodes = [
    {
      id: 0,
      reflexive: false
    },
    {
      id: 1,
      reflexive: false
    },
    {
      id: 2,
      reflexive: false
    },
    {
      id: 3,
      reflexive: false
    },
    {
      id: 4,
      reflexive: false
    },
    {
      id: 5,
      reflexive: false
    }
  ];

  lastNodeId = 5;

  couleur = [];

  for (i = j = 0; j <= 10000; i = ++j) {
    couleur[i.toString()] = i;
  }

  links = [
    {
      source: nodes[0],
      target: nodes[1],
      left: false,
      right: false
    },
    {
      source: nodes[0],
      target: nodes[4],
      left: false,
      right: false
    },
    {
      source: nodes[0],
      target: nodes[5],
      left: false,
      right: false
    },
    {
      source: nodes[1],
      target: nodes[2],
      left: false,
      right: false
    },
    {
      source: nodes[2],
      target: nodes[3],
      left: false,
      right: false
    },
    {
      source: nodes[4],
      target: nodes[3],
      left: false,
      right: false
    },
    {
      source: nodes[4],
      target: nodes[5],
      left: false,
      right: false
    },
    {
      source: nodes[5],
      target: nodes[1],
      left: false,
      right: false
    },
    {
      source: nodes[5],
      target: nodes[2],
      left: false,
      right: false
    },
    {
      source: nodes[5],
      target: nodes[3],
      left: false,
      right: false
    }
  ];

  // handles to link and node element groups
  pathsGroup = svg.append('svg:g');

  path = pathsGroup.selectAll('path');

  circlesGroup = svg.append('svg:g');

  circle = circlesGroup.selectAll('g');

  // update force layout (called automatically each iteration)
  tick = function() {
    // draw directed edges with proper padding from node centers
    path.attr('d', function(d) {
      var deltaX, deltaY, dist, normX, normY, sourcePadding, sourceX, sourceY, targetPadding, targetX, targetY;
      deltaX = d.target.x - d.source.x;
      deltaY = d.target.y - d.source.y;
      dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      normX = deltaX / dist;
      normY = deltaY / dist;
      sourcePadding = 12;
      targetPadding = 12;
      sourceX = d.source.x + sourcePadding * normX;
      sourceY = d.source.y + sourcePadding * normY;
      targetX = d.target.x - (targetPadding * normX);
      targetY = d.target.y - (targetPadding * normY);
      return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
    });
    return circle.attr('transform', function(d) {
      return `translate(${d.x}, ${d.y})`;
    });
  };

  // init D3 force layout
  force = d3.layout.force().nodes(nodes).links(links).size([width / 2, height / 2]).linkDistance(80).charge(-500).on('tick', tick);

  // mouse event vars
  selected_node = null;

  selected_link = null;

  mousedown_link = null;

  mousedown_node = null;

  mouseup_node = null;

  // only respond once per keydown
  lastKeyDown = -1;

  resetMouseVars = function() {
    mousedown_node = null;
    mouseup_node = null;
    mousedown_link = null;
  };

  // update graph (called when needed)
  restart = function() {
    var arete, c1, c2, enscoul, g, k, len, len1, m, n, na, o, ref, sommet, v;
    // path (link) group
    path = path.data(links);
    // update existing links
    path.style('stroke', "black").style('fill', "black").style('stroke-width', '4px').classed('selected', function(d) {
      return d === selected_link;
    });
    // add new links
    path.enter().append('svg:path').attr('class', 'link').style('stroke', "black").style('fill', "black").style('stroke-width', '4px').classed('selected', function(d) {
      return d === selected_link;
    }).on('mousedown', function(d) {
      if (d3.event.ctrlKey) {
        
        // select link
        mousedown_link = d;
        if (mousedown_link === selected_link) {
          selected_link = null;
        } else {
          selected_link = mousedown_link;
        }
        selected_node = null;
        return restart();
      }
    });
    
    // remove old links
    path.exit().remove();
    // circle (node) group
    // NB: the function arg is crucial here! nodes are known by id, not by index!
    circle = circle.data(nodes, function(d) {
      return d.id;
    });
    // update existing nodes (reflexive & selected visual states)
    circle.selectAll('circle').classed('selected', function(d) {
      return d === selected_node;
    }).style('fill', function(d) {
      return colors(couleur[d.id]);
    }).classed('reflexive', function(d) {
      return d.reflexive;
    });
    // add new nodes
    g = circle.enter().append('svg:g');
    g.append('svg:circle').attr('class', 'node').attr('r', 12).classed('selected', function(d) {
      return d === selected_node;
    //.style('fill', (d) -> if d == selected_node then d3.rgb(colors(couleur[d.id])).brighter().toString() else colors(couleur[d.id]))
    }).style('fill', function(d) {
      return colors(couleur[d.id]);
    }).style('stroke', function(d) {
      return d3.rgb(colors(couleur[d.id])).darker().toString();
    }).classed('reflexive', function(d) {
      return d.reflexive;
    }).on('mouseover', function(d) {
      if (!mousedown_node || d === mousedown_node) {
        return;
      }
      
      // enlarge target node
      d3.select(this).attr('transform', 'scale(1.1)');
    }).on('mouseout', function(d) {
      if (!mousedown_node || d === mousedown_node) {
        return;
      }
      
      // unenlarge target node
      d3.select(this).attr('transform', '');
    }).on('mousedown', function(d) {
      if (d3.event.ctrlKey) {
        return;
      }
      
      // select node
      mousedown_node = d;
      if (mousedown_node === selected_node) {
        selected_node = null;
      } else {
        selected_node = mousedown_node;
      }
      selected_link = null;
      // reposition drag line
      drag_line.classed('hidden', false).attr('d', `M${mousedown_node.x}, ${mousedown_node.y}L${mousedown_node.x}, ${mousedown_node.y}`);
      restart();
    }).on('mouseup', function(d) {
      var direction, link, source, target;
      if (!mousedown_node) {
        return;
      }
      
      // needed by FF
      drag_line.classed('hidden', true);
      // check for drag-to-self
      mouseup_node = d;
      if (mouseup_node === mousedown_node) {
        resetMouseVars();
        return;
      }
      // unenlarge target node
      d3.select(this).attr('transform', '');
      // add link to graph (update if exists)
      // NB: links are strictly source < target; arrows separately specified by booleans
      source = void 0;
      target = void 0;
      direction = void 0;
      if (mousedown_node.id < mouseup_node.id) {
        source = mousedown_node;
        target = mouseup_node;
        direction = 'right';
      } else {
        source = mouseup_node;
        target = mousedown_node;
        direction = 'left';
      }
      link = void 0;
      link = links.filter(function(l) {
        return l.source === source && l.target === target;
      })[0];
      if (!link) {
        link = {
          source: source,
          target: target,
          left: false,
          right: false
        };
        links.push(link);
      }
      // select new link
      selected_link = link;
      selected_node = null;
      return restart();
    });
    
    // show node IDs
    g.append('svg:text').attr('x', 0).attr('y', 4).attr('class', 'id').text(function(d) {
      return d.id;
    });
    // remove old nodes
    circle.exit().remove();
    // set the graph in motion
    force.start();
    // calculs sur les degrés et les couleurs
    $("#sommets").empty().append("<th>sommets</th>");
    $("#entrants").empty().append("<th>degrés</th>");
    $("#conflits").empty();
    for (m = 0, len = nodes.length; m < len; m++) {
      sommet = nodes[m];
      $("#sommets").append(`<td>${sommet.id}</td>`);
      na = 0;
      c1 = couleur[sommet.id];
      for (n = 0, len1 = links.length; n < len1; n++) {
        arete = links[n];
        if (arete.source === sommet) {
          na += 1;
          c2 = couleur[arete.target.id];
          if (c1 === c2) {
            $("#conflits").append(`<li>Les sommets ${sommet.id} et ${arete.target.id} sont de la même couleur</li>`);
          }
        }
        if (arete.target === sommet) {
          na += 1;
        }
      }
      $("#entrants").append(`<td>${na}</td>`);
    }
    enscoul = {};
    for (i = o = 0, ref = lastNodeId; (0 <= ref ? o <= ref : o >= ref); i = 0 <= ref ? ++o : --o) {
      enscoul[couleur[i]] = couleur[i];
    }
    $("#chroma1").text(`Le graphe est actuellement colorié en ${((function() {
      var results;
      results = [];
      for (k in enscoul) {
        v = enscoul[k];
        results.push(v);
      }
      return results;
    })()).length} couleurs. Peut-on faire moins ?`);
  };

  mousedown = function() {
    var node, point;
    // prevent I-bar on drag
    //d3.event.preventDefault();
    // because :active only works in WebKit?
    svg.classed('active', true);
    if (d3.event.ctrlKey || mousedown_node || mousedown_link) {
      return;
    }
    // insert new node at point
    point = d3.mouse(this);
    node = {
      id: ++lastNodeId,
      reflexive: false
    };
    couleur[node.id] = node.id;
    node.x = point[0];
    node.y = point[1];
    nodes.push(node);
    restart();
  };

  mousemove = function() {
    if (!mousedown_node) {
      return;
    }
    // update drag line
    drag_line.attr('d', `M${mousedown_node.x}, ${mousedown_node.y}L${(d3.mouse(this)[0])}, ${(d3.mouse(this)[1])}`);
    restart();
  };

  mouseup = function() {
    if (mousedown_node) {
      // hide drag line
      drag_line.classed('hidden', true).style('marker-end', '');
    }
    // because :active only works in WebKit?
    svg.classed('active', false);
    // clear mouse event vars
    resetMouseVars();
  };

  spliceLinksForNode = function(node) {
    var toSplice;
    toSplice = links.filter(function(l) {
      return l.source === node || l.target === node;
    });
    return toSplice.map(function(l) {
      return links.splice(links.indexOf(l), 1);
    });
  };

  keydown = function() {
    var index;
    d3.event.preventDefault();
    if (lastKeyDown !== -1) {
      return;
    }
    lastKeyDown = d3.event.keyCode;
    // ctrl
    if (d3.event.keyCode === 17) {
      circle.call(force.drag);
      svg.classed('ctrl', true);
    }
    if (!selected_node && !selected_link) {
      return;
    }
    switch (d3.event.keyCode) {
      // backspace
      case 8:
      case 46:
        // delete
        if (selected_node) {
          nodes.splice(nodes.indexOf(selected_node), 1);
          spliceLinksForNode(selected_node);
        } else if (selected_link) {
          links.splice(links.indexOf(selected_link), 1);
        }
        selected_link = null;
        selected_node = null;
        restart();
        break;
      // M pour moins (diminuer couleur)
      case 77:
      case 109:
        if (selected_node) {
          index = selected_node.id;
          couleur[index] -= 1;
          if (couleur[index] < 0) {
            couleur[index] += 10;
          }
        }
        restart();
        break;
      // P pour plus (augmenter couleur)
      case 80:
      case 112:
        if (selected_node) {
          index = selected_node.id;
          couleur[index] += 1;
          if (couleur[index] > 9) {
            couleur[index] -= 10;
          }
        }
        restart();
    }
  };

  keyup = function() {
    lastKeyDown = -1;
    // ctrl
    if (d3.event.keyCode === 17) {
      circle.on('mousedown.drag', null).on('touchstart.drag', null);
      svg.classed('ctrl', false);
    }
  };

  // app starts here
  svg.on('mousedown', mousedown).on('mousemove', mousemove).on('mouseup', mouseup);

  d3.select(window).on('keydown', keydown).on('keyup', keyup);

  restart();

  //Drag an Drop interface
  DnDFileController = function(selector, onDropCallback) {
    var el_;
    el_ = document.querySelector(selector);
    this.dragenter = function(e) {
      e.stopPropagation();
      e.preventDefault();
      el_.classList.add('dropping');
      return $("#upload").addClass("slim");
    };
    this.dragover = function(e) {
      e.stopPropagation();
      return e.preventDefault();
    };
    this.dragleave = function(e) {
      e.stopPropagation();
      e.preventDefault();
      el_.classList.remove('dropping');
      return $("#upload").removeClass("slim");
    };
    this.drop = function(e) {
      e.stopPropagation();
      e.preventDefault();
      el_.classList.remove('dropping');
      onDropCallback(e.dataTransfer.files, e);
      return $("#upload").removeClass("slim").hide();
    };
    el_.addEventListener('dragenter', this.dragenter, false);
    el_.addEventListener('dragover', this.dragover, false);
    el_.addEventListener('dragleave', this.dragleave, false);
    return el_.addEventListener('drop', this.drop, false);
  };

  //#################################################################
  //Drag and Drop file
  // à  factoriser à l'occasion
  dnd = new DnDFileController('#upload', function(files) {
    var f, reader;
    f = files[0];
    reader = new FileReader;
    reader.onloadend = function(e) {
      var data, l, len, m, ref, t;
      data = JSON.parse(this.result);
      console.log(data);
      pathsGroup.remove();
      circlesGroup.remove();
      
      // handles to link and node element groups
      pathsGroup = svg.append('svg:g');
      path = pathsGroup.selectAll('path');
      circlesGroup = svg.append('svg:g');
      circle = circlesGroup.selectAll('g');
      lastNodeId = data.lastNodeId;
      nodes = data.nodes;
      links = [];
      ref = data.links;
      for (m = 0, len = ref.length; m < len; m++) {
        l = ref[m];
        t = {};
        t.source = nodes[l.source.id];
        t.target = nodes[l.target.id];
        t.left = false;
        t.right = false;
        links.push(t);
      }
      console.log(links);
      force = d3.layout.force().nodes(nodes).links(links).size([width / 2, height / 2]).linkDistance(80).charge(-200).on('tick', tick);
      return restart();
    };
    reader.readAsText(f);
  });

  //###################################################################
  $("#importJSON").on("click", function() {
    return $("#upload").show();
  });

  $("#upload .close").on("click", function() {
    return $("#upload").hide();
  });

  save = function(type) {
    var dataStr, dlAnchorElem, html, stringValue, svgBlob;
    dataStr = `data:text/${type};charset=utf-8,`;
    stringValue = prompt("Nom du fichier ?", stringValue);
    switch (type) {
      case "json":
        dataStr += encodeURIComponent(JSON.stringify({
          nodes: nodes,
          links: links,
          lastNodeId: lastNodeId
        }));
        break;
      case "svg":
        html = d3.select("#graf").select("svg").attr("title", "svg_title").attr("version", 1.1).attr("xmlns", "http://www.w3.org/2000/svg").node().parentNode.innerHTML;
        svgBlob = new Blob([html], {
          type: "image/svg+xml;charset=utf-8"
        });
        dataStr = URL.createObjectURL(svgBlob);
    }
    dlAnchorElem = document.getElementById('save');
    dlAnchorElem.setAttribute("href", dataStr);
    dlAnchorElem.setAttribute("download", `${stringValue}.${type}`);
    return dlAnchorElem.click();
  };

  $(function() {
    //  console.log nodes,links
    $("#genJSON").on("click", function() {
      return save("json");
    });
    $("#genSVG").on("click", function() {
      return save("svg");
    });
    $("#hints, #rules, #defs").hide();
    $("#hintsToggler").on("click", function() {
      return $("#hints").toggle();
    });
    $("#rulesToggler").on("click", function() {
      return $("#rules").toggle();
    });
    return $("#defsToggler").on("click", function() {
      return $("#defs").toggle();
    });
  });

}).call(this);
